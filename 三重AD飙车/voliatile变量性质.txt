

       volatile 类型是这样的，其数据确实可能在未知的情况下发生
变化。比如，硬件设备的终端更改了它，现在硬件设备往往也有自
己的私有内存地址，比如显存，他们一般是通过映象的方式，反映
到一段特定的内存地址当中，这样，在某些条件下，程序就可以直
接访问这些私有内存了。另外，比如共享的内存地址，多个程序都
对它操作的时候。你的程序并不知道，这个内存何时被改变了。如
果不加这个voliatile修饰，程序是利用catch当中的数据，那个可能
是过时的了，加了 voliatile，就在需要用的时候，程序重新去那个
地址去提取，保证是最新的。归纳起来如下：
1. volatile变量可变允许除了程序之外的比如硬件来修改他的内容 
2. 访问该数据任何时候都会直接访问该地址处内容，即通过cache
    提高访问速度的优化被取消 



volatile，关键字volatile 确保本条指令不会因C 编译器的优化而被
省略，且要求每次直接读值。例如用while((unsigned char *)0x20)
时，有时系统可能不真正去读0x20的值，而是用第一次读出的值，
如果这样，那这个循环可能是个死循环。用了volatile 则要求每次
都去读0x20的实际值。
